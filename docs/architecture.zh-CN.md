# 架构详解

## 概览

claude-trinity 为 Claude Code 实现了三层记忆架构。每一层有不同的职责和触发机制。

```
                    ┌─────────────────────────┐
                    │     Claude Code CLI      │
                    └──────────┬──────────────┘
                               │
              ┌────────────────┼────────────────┐
              │                │                │
              ▼                ▼                ▼
     ┌────────────────┐ ┌───────────────┐ ┌──────────────┐
     │   L1 热层       │ │   L2 温层      │ │   L3 库层     │
     │                │ │               │ │              │
     │ .claude/rules/ │ │ MEMORY.md     │ │ claude-mem   │
     │ *.md 文件      │ │ crossmem.md   │ │ SQLite+RAG   │
     │                │ │ facts/*.json  │ │              │
     │ 触发方式：      │ │ 触发方式：     │ │ 触发方式：    │
     │ 路径匹配       │ │ SessionStart  │ │ 语义查询      │
     │ （自动）       │ │ （自动）      │ │ （按需）      │
     │                │ │               │ │              │
     │ 延迟：0ms      │ │ 延迟：<1s     │ │ 延迟：~2s    │
     │ 容量：~10 文件  │ │ 容量：~50 条  │ │ 容量：∞      │
     └────────────────┘ └───────────────┘ └──────────────┘
```

## L1 — 热层：项目规则

### 工作原理

Claude Code 原生支持 `.claude/rules/` 目录。打开会话时，Claude 会自动加载匹配的规则文件。

规则可放在两个层级：
- **全局**：`~/.claude/rules/` — 对所有项目生效
- **项目**：`<project>/.claude/rules/` — 仅对该项目生效

### 设计决策

**为什么用 Markdown？** 这是 Claude Code 的原生格式，无需预处理。

**为什么用路径触发？** 不同项目有不同的规范。Docker 项目和 React 项目需要不同的规则。路径自动加载意味着零手动操作。

**为什么用示例模板而非真实规则？** 真实规则包含业务信息（平台名、内部 API、团队规范）。模板展示的是*有效规则的模式*，同时保持通用性。

### 容量建议

每个规则文件会占用上下文窗口。建议保持单文件聚焦（一个领域一个文件），总规则文件控制在 ~10 个以内。

## L2 — 温层：核心记忆

### 组成部分

#### MEMORY.md
中央索引文件，通过 Claude Code 的自动记忆功能在每次会话时加载，包含：
- 架构参考（让 Claude 知道怎么用这套系统）
- 核心原则（调查先行、实践验证等）
- 用户偏好（模型配置、工具选择、沟通风格）
- 快速参考（路径、端点、API 配置）
- Compact 保护指令（告诉 Claude 在上下文压缩时保留此文件）

#### crossmem.md
跨项目观察记录，按优先级分类：
- **P0**：重大教训（耗时 >30 分钟或导致数据丢失）— 永不自动清除
- **P1**：重要模式（节省大量时间）— 保留 6 个月
- **P2**：小技巧 — 超过 50 条时清除

通过 SessionStart hook 加载。

#### facts/*.json
结构化项目事实，通过 `superseded_by` 实现版本追溯：
```json
{
  "id": "fact-001",
  "value": "PostgreSQL 15",
  "superseded_by": null    ← 当前版本
}
{
  "id": "fact-002",
  "value": "PostgreSQL 14",
  "superseded_by": "fact-001"  ← 历史版本
}
```

### 设计决策

**为什么不直接用 CLAUDE.md？** CLAUDE.md 是项目级的，随项目代码一起版本控制。MEMORY.md 是个人的，跨所有项目持久化，包含你不想放进 Git 的信息（API 路径、模型偏好、个人工作流笔记）。

**为什么用 superseded 机制？** 删除旧事实会丢失历史。调试时，知道*什么变了*往往比知道*现在是什么*更有价值。superseded 链提供了审计追踪。

**为什么 crossmem 限制 50 条？** 上下文窗口预算。每条都消耗 token。P0 值得花这个代价；P2 不值得。淘汰策略让总量可控。

## L3 — 库层：深度记忆

### 工作原理

可选的 `claude-mem` 插件提供：
1. **自动捕获**：通过 Hooks 观察 Claude 的工具使用，捕获重要观察
2. **向量化**：使用本地模型（all-MiniLM-L6-v2，无需 API key）对观察进行嵌入
3. **存储**：SQLite 处理结构化数据，Chroma 处理向量搜索
4. **检索**：语义搜索返回相关的历史观察

### L3 何时激活

L3 是按需的，不会在每次会话中加载。触发场景：
- 用户问"之前遇到过这个错误吗？" → 对观察历史进行语义搜索
- Claude 遇到复杂问题 → 主动搜索相关的过去经验
- 用户显式调用 `/mem-search` → 直接向量搜索

### 设计决策

**为什么是可选的？** L1 和 L2 提供了 80% 的价值且零依赖。L3 补充剩余 20%，但需要 Bun/Node.js 且增加复杂度。想要简单部署的用户可以完全跳过。

**为什么用本地嵌入？** 不需要 API key，零成本，不依赖网络。代价是嵌入质量不如 OpenAI 的模型，但对于代码相关的语义搜索，MiniLM-L6 够用了。

**为什么同时用 SQLite + Chroma？** SQLite 处理结构化查询（时间范围、分类、精确匹配），Chroma 处理语义相似度。不同的访问模式需要不同的存储引擎。

## 数据流

```
用户启动 Claude Code 会话
        │
        ├──→ L1：自动加载当前目录的规则
        ├──→ L2：自动加载 MEMORY.md（内置）
        ├──→ L2：SessionStart hook 加载 crossmem.md
        │
        │   （会话进行中...）
        │
        ├──→ Claude 解决了一个问题
        │    ├──→ 问用户"要不要记下来？"
        │    ├──→ 如果要：写入 crossmem.md（P0/P1/P2）
        │    └──→ 如果 L3 激活：自动捕获到 claude-mem
        │
        ├──→ Claude 遇到复杂问题
        │    └──→ 如果 L3 激活：搜索历史观察
        │
        └──→ 会话结束
             └──→ L3 观察持久化到 SQLite/Chroma
```

## 安全注意事项

- MEMORY.md 和 crossmem.md 可能包含项目信息。请放在 `~/.claude/`（不受版本控制）而非项目目录中。
- 永远不要在记忆文件中存储 API key、token 或凭证。使用环境变量，仅引用变量名。
- `SECRET_PHRASE_IN_MEMORY` 字段是一个金丝雀值——如果 Claude 在回复中输出了它，说明上下文发生了泄露。
- facts/*.json 不应包含敏感数据（密码、token）。只存储结构性事实（数据库类型、框架版本等）。
